import type { JSONSchema, TSESLint } from '@typescript-eslint/utils';
import { compile } from 'json-schema-to-typescript';
import path from 'path';
import { GeneratorContext } from './context.js';
import { formatText, joinLines, prettierConfig, toPascalCase } from './text.js';

async function compileSchema(
  typeName: string,
  schema: JSONSchema.JSONSchema4
): Promise<string> {
  const code = await compile(schema, typeName, {
    bannerComment: '',
    style: prettierConfig,
    format: false,
    strictIndexSignatures: true,
    enableConstEnums: false,
  });

  return code.replace(`${typeName} =`, `${typeName} = 'off' |`);
}

const ruleLevelString = {
  enum: ['off', 'error', 'warn'],
};

function adjustSchema(schema: JSONSchema.JSONSchema4): JSONSchema.JSONSchema4 {
  if (schema.anyOf != null) {
    for (const subSchema of schema.anyOf) {
      adjustSchema(subSchema);
    }

    return schema;
  }

  if (Array.isArray(schema.prefixItems)) {
    // some rules use prefixItems instead of items. we can treat them as items
    schema.items = [schema.prefixItems, schema.items ?? []].flat();
  }

  if (Array.isArray(schema.items)) {
    // work around shared / nested schemas
    if (schema.items[0] !== ruleLevelString) {
      schema.items.unshift(ruleLevelString);
    }
  } else if (schema.items !== undefined) {
    if (schema.items.oneOf != null || schema.items.anyOf != null) {
      const oldItem = schema.items;
      schema.items = [ruleLevelString];
      schema.additionalItems = oldItem;
    } else {
      schema.items = [ruleLevelString, schema.items];
    }
  } else {
    schema = {
      type: 'array',
      items: [ruleLevelString, schema],
    };
  }

  if (typeof schema.minItems === 'number') {
    schema.minItems += 1;
  } else {
    schema.minItems = 1;
  }

  if (typeof schema.maxItems === 'number') {
    schema.maxItems += 1;
  }

  return schema;
}

function isRefValue(val: unknown): val is string {
  return typeof val === 'string' && val.startsWith('#/');
}

function recursivelyFixRefs(
  schema: JSONSchema.JSONSchema4 | string | null | boolean,
  idx: number
): void {
  if (schema == null || typeof schema !== 'object') {
    return;
  }

  for (const key in schema) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- known safe
    const current = schema[key];
    if (current == null) {
      continue;
    }

    if (Array.isArray(current)) {
      current.forEach((subSchema, i) => {
        recursivelyFixRefs(subSchema, i);
      });
    } else if (key === '$ref' && isRefValue(current)) {
      schema[key] = `#/items/${idx + 1}/${current.substring(2)}`;
    } else if (typeof current === 'object') {
      recursivelyFixRefs(current, idx);
    }
  }
}

type RuleSchema = JSONSchema.JSONSchema4 | readonly JSONSchema.JSONSchema4[];

function normalizeSchema(schema: RuleSchema): JSONSchema.JSONSchema4 {
  if (Array.isArray(schema)) {
    const schemaArray: JSONSchema.JSONSchema4[] = schema;
    schema.forEach((ref, i) => {
      recursivelyFixRefs(ref, i);
    });

    return {
      type: 'array',
      items: [ruleLevelString, ...schemaArray],
      minItems: 1,
    };
  }

  return adjustSchema(schema);
}

/**
 * Find and filter doc comment strings out of rule meta data.
 */
function getMetaDocStrings(docs?: TSESLint.RuleMetaDataDocs): string[] {
  if (!docs) {
    return [];
  }

  return [docs.description, docs.url ? `@see ${docs.url}` : ''].filter(Boolean);
}

/**
 * Generate rule type definitions as a string
 */
async function generateRuleTypeDef(
  ruleName: string,
  rule: { meta: TSESLint.RuleMetaData<string> }
): Promise<string> {
  const typeName = toPascalCase(ruleName);
  const schema = normalizeSchema(rule.meta?.schema ?? []);

  schema.description = joinLines(...getMetaDocStrings(rule.meta.docs));

  return compileSchema(typeName, schema);
}

export async function generateRuleTypeFiles(
  context: GeneratorContext,
  rules: Record<string, TSESLint.RuleModule<string, unknown[]>>,
  directory: string
): Promise<void> {
  for await (const [ruleName, rule] of Object.entries(rules)) {
    const ruleTypeDef = await generateRuleTypeDef(ruleName, rule);

    const filepath = path.resolve(directory, `${ruleName}.ts`);

    const fileText = formatText(
      joinLines(context.autoGeneratedNote, '', ruleTypeDef)
    );

    context.writeFile(filepath, fileText);

    console.info('Wrote', path.relative(context.cwd, filepath));
  }
}
