import type { TSESLint } from '@typescript-eslint/utils';
import { mkdirp } from 'mkdirp';
import path from 'path';
import util from 'util';
import { GeneratorContext, GeneratorOptions, setupContext } from './context.js';
import { generateRuleTypeFiles } from './generateRuleTypeFiles.js';
import {
  PendingPlugin,
  loadEslintPlugins,
  type Plugin,
} from './loadEslintPlugins.js';
import { createDoc, formatText, toPascalCase } from './text.js';

const debug = util.debuglog('generate-types');

/**
 * normalize function rule into object
 */
function normalizeRule(
  ruleCreator: TSESLint.RuleCreateFunction
): TSESLint.RuleModule<string, unknown[]> {
  return {
    defaultOptions: [],
    meta: {
      messages: {},
      schema: {},
      type: 'suggestion',
    },
    create: ruleCreator,
  };
}

async function processPlugin(context: GeneratorContext, plugin: PendingPlugin) {
  debug(`processing plugin \`%s\``, plugin.name);

  if (!plugin.rules) {
    debug(`no rules found. skipping...`);
    return;
  }

  const rules: Plugin['rules'] = {};
  for (const [ruleName, rule] of Object.entries(plugin.rules)) {
    if (typeof rule === 'function') {
      rules[ruleName] = normalizeRule(rule);
    } else if (rule.meta.deprecated === true) {
      // skip deprecated rules
      continue;
    } else {
      rules[ruleName] = rule;
    }
  }

  const pluginDir = path.resolve(context.target, plugin.shortName);
  await mkdirp(pluginDir);

  await generateRuleTypeFiles(context, rules, pluginDir);

  const ruleNames = Object.keys(rules).map((rule) => ({
    name: rule,
    safeName: toPascalCase(rule.replace(`${plugin.shortName}/`, '')),
  }));

  const rulePrefix =
    plugin.shortName === 'eslint' ? '' : `${plugin.shortName}/`;

  const typeImports = ruleNames.map(
    (rule) =>
      `import type { ${rule.safeName} } from '../${plugin.shortName}/${rule.name}.js'`
  );

  const interfaceItem = {
    doc: createDoc(`\`${plugin.name}\` Rules`),
    name: toPascalCase(plugin.shortName),
    members: ruleNames.map(
      (rule) => `'${rulePrefix}${rule.name}': ${rule.safeName};`
    ),
  };

  const indexFileText = [
    ...typeImports,
    '',
    interfaceItem.doc,
    `export interface ${interfaceItem.name} {`,
    ...interfaceItem.members,
    '}',
  ].join('\n');

  context.writeFile(
    path.resolve(context.target, plugin.shortName, 'index.ts'),
    formatText([context.autoGeneratedNote, '', indexFileText].join('\n'))
  );

  debug('Wrote types for ', plugin.name);
}

export async function generateRuleTypes(
  options: GeneratorOptions
): Promise<void> {
  const context = setupContext(options);
  const plugins = loadEslintPlugins();

  for await (const plugin of plugins) {
    processPlugin(context, plugin);
  }

  console.info('Done!');
}
