import type { TSESLint } from "@typescript-eslint/utils";
import { mkdirp } from "mkdirp";
import path from "path";
import util from "util";
import { GeneratorContext, GeneratorOptions, setupContext } from "./context.js";
import { findPlugins, type Plugin } from "./find-plugins.js";
import { generateRuleTypeFiles } from "./generate-rule-type-files.js";
import { formatText, toPascalCase } from "./text-utils.js";

const debug = util.debuglog("generate-types");

/**
 * normalize function rule into object
 */
function normalizeRule(
  ruleCreator: TSESLint.RuleCreateFunction
): TSESLint.RuleModule<string> {
  return {
    defaultOptions: [],
    meta: {
      messages: {},
      schema: {},
      type: "suggestion",
    },
    create: ruleCreator,
  };
}

function normalizeRules(initialRules: Plugin["rules"]): RuleRecord {
  const rules: RuleRecord = {};

  for (const [ruleName, rule] of Object.entries(initialRules ?? {})) {
    if (typeof rule === "function") {
      rules[ruleName] = {
        defaultOptions: [],
        meta: {
          messages: {},
          schema: {},
          type: "suggestion",
        },
        create: rule,
      };
    } else if (rule.meta.deprecated === true) {
      // skip deprecated rules
      continue;
    } else {
      rules[ruleName] = rule;
    }
  }

  return rules;
}

type RuleRecord = Record<string, TSESLint.RuleModule<string, unknown[]>>;

async function generatePluginIndexFile(
  context: GeneratorContext,
  plugin: Plugin,
  rules: RuleRecord
) {
  const ruleNames = Object.keys(rules).map((ruleName) => ({
    name: ruleName,
    safeName: toPascalCase(ruleName.replace(`${plugin.name}/`, "")),
  }));

  const rulePrefix = plugin.name === "eslint" ? "" : `${plugin.name}/`;

  const importStatements = ruleNames
    .map(
      (rule) =>
        `import type { ${rule.safeName} } from '../${plugin.name}/${rule.name}.js';`
    )
    .join("\n");

  const interfaceMembers = ruleNames
    .map((rule) => `'${rulePrefix}${rule.name}': ${rule.safeName};`)
    .join("\n");

  const textContent = `
  ${context.autoGeneratedNote}
  ${importStatements}

  /**
   * ${plugin.module} Rules
   */
  export interface ${toPascalCase(plugin.name)} {
    ${interfaceMembers}
  }
  `;

  context.write(
    path.resolve(context.outDir, plugin.name, "index.ts"),
    formatText(textContent)
  );

  debug("Wrote types for ", plugin.module);
}

async function processPlugin(context: GeneratorContext, plugin: Plugin) {
  debug(`processing plugin \`%s\``, plugin.module);

  if (!plugin.rules) {
    debug(`no rules found. skipping...`);
    return;
  }

  const rules = normalizeRules(plugin.rules);

  const pluginDir = path.resolve(context.outDir, plugin.name);

  await mkdirp(pluginDir);

  await generateRuleTypeFiles(context, rules, pluginDir);

  await generatePluginIndexFile(context, plugin, rules);
}

export async function generateRuleTypes(
  options: GeneratorOptions
): Promise<void> {
  const context = setupContext(options);
  const plugins = findPlugins();

  for await (const plugin of plugins) {
    processPlugin(context, plugin);
  }

  console.info("Done!");
}
